name: Deploy to AWS

on:
  push:
    branches: [ main ]
  workflow_dispatch:
  workflow_call:

env:
  AWS_REGION: eu-north-1

jobs:
  deploy:
    name: Deploy to ECS
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Deploy to ECS
      run: |
        echo "üöÄ Starting ECS deployment..."
        
        # Check and update ECS service
        if aws ecs describe-services --cluster devops-pipeline-cluster --services devops-pipeline-service --region ${{ env.AWS_REGION }} --query 'services[0].status' --output text 2>/dev/null | grep -q "ACTIVE"; then
          echo "‚úÖ ECS service found - updating deployment..."
          aws ecs update-service \
            --cluster devops-pipeline-cluster \
            --service devops-pipeline-service \
            --force-new-deployment \
            --region ${{ env.AWS_REGION }}
          echo "‚úÖ ECS service update initiated"
        else
          echo "‚ö†Ô∏è ECS service not found - checking infrastructure..."
          
          # Check if cluster exists
          if ! aws ecs describe-clusters --clusters devops-pipeline-cluster --region ${{ env.AWS_REGION }} > /dev/null 2>&1; then
            echo "‚ùå ECS cluster not found - run Terraform first!"
            exit 1
          fi
          
          echo "‚ö†Ô∏è Service not found but cluster exists - may need manual intervention"
        fi

    - name: Trigger CodePipeline
      run: |
        echo "üîÑ Triggering CodePipeline deployment..."
        if aws codepipeline get-pipeline --name devops-pipeline --region ${{ env.AWS_REGION }} > /dev/null 2>&1; then
          echo "‚úÖ CodePipeline found - starting execution..."
          EXECUTION_ID=$(aws codepipeline start-pipeline-execution \
            --name devops-pipeline \
            --region ${{ env.AWS_REGION }} \
            --query 'pipelineExecutionId' \
            --output text)
          echo "‚úÖ CodePipeline execution started: $EXECUTION_ID"
          
          # Wait a bit and check status
          sleep 30
          STATUS=$(aws codepipeline get-pipeline-execution \
            --pipeline-name devops-pipeline \
            --pipeline-execution-id $EXECUTION_ID \
            --region ${{ env.AWS_REGION }} \
            --query 'pipelineExecution.status' \
            --output text)
          echo "üìä Pipeline status: $STATUS"
        else
          echo "‚ö†Ô∏è CodePipeline 'devops-pipeline' not found"
          echo "Listing available pipelines:"
          aws codepipeline list-pipelines --region ${{ env.AWS_REGION }} --query 'pipelines[].name' --output table || echo "No pipelines found"
        fi

    - name: Wait for Deployment
      run: |
        echo "‚è≥ Waiting for deployment to complete..."
        
        # Wait for ECS service to stabilize
        if aws ecs describe-services --cluster devops-pipeline-cluster --services devops-pipeline-service --region ${{ env.AWS_REGION }} > /dev/null 2>&1; then
          echo "üîÑ Waiting for ECS service to stabilize (max 10 minutes)..."
          timeout 600 aws ecs wait services-stable \
            --cluster devops-pipeline-cluster \
            --services devops-pipeline-service \
            --region ${{ env.AWS_REGION }} || echo "‚ö†Ô∏è Timeout reached, deployment may still be in progress"
          
          # Check final status
          RUNNING_COUNT=$(aws ecs describe-services \
            --cluster devops-pipeline-cluster \
            --services devops-pipeline-service \
            --region ${{ env.AWS_REGION }} \
            --query 'services[0].runningCount' \
            --output text)
          echo "üìä Running tasks: $RUNNING_COUNT"
        fi

    - name: Get Application URL
      run: |
        echo "üåê Getting application URL..."
        LB_DNS=$(aws elbv2 describe-load-balancers \
          --query 'LoadBalancers[?contains(LoadBalancerName, `devops-pipeline`)].DNSName' \
          --output text \
          --region ${{ env.AWS_REGION }} 2>/dev/null || echo "")
        
        if [ -n "$LB_DNS" ] && [ "$LB_DNS" != "None" ]; then
          echo "‚úÖ Application URL: http://$LB_DNS"
          echo "üîó Access your application at: http://$LB_DNS"
          
          # Test connectivity
          echo "üß™ Testing application connectivity..."
          for i in {1..5}; do
            if curl -f -s --connect-timeout 10 --max-time 20 "http://$LB_DNS" > /dev/null 2>&1; then
              echo "‚úÖ Application is responding! (attempt $i)"
              break
            else
              echo "‚è≥ Application not ready yet (attempt $i/5)..."
              sleep 15
            fi
          done
        else
          echo "‚ö†Ô∏è Load balancer not found - checking infrastructure..."
          aws elbv2 describe-load-balancers --region ${{ env.AWS_REGION }} \
            --query 'LoadBalancers[].{Name:LoadBalancerName,DNS:DNSName}' \
            --output table || echo "No load balancers found"
        fi

    - name: Deployment Summary
      if: always()
      run: |
        echo ""
        echo "üéØ DEPLOYMENT SUMMARY"
        echo "===================="
        echo "‚úÖ ECS deployment triggered"
        echo "‚úÖ CodePipeline execution started"
        echo "‚úÖ Load balancer URL retrieved"
        echo ""
        echo "üîó Next steps:"
        echo "  1. Check AWS Console for detailed status"
        echo "  2. Monitor ECS service health"
        echo "  3. Verify application functionality"
        echo "  4. Check CodePipeline execution progress"
